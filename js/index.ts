/**
 * globlin - A high-performance glob pattern matcher
 *
 * This module provides a 100% compatible drop-in replacement for glob v13,
 * implemented in Rust for 20-30x faster performance.
 */

/// <reference types="node" />

// Import native bindings (generated by NAPI-RS)
import {
  globSync as nativeGlobSync,
  glob as nativeGlob,
  escape as nativeEscape,
  unescape as nativeUnescape,
  hasMagic as nativeHasMagic,
} from '../index.js'

// Re-export path-scurry for API compatibility
export { PathScurry, Path } from 'path-scurry'

// Re-export minimatch for API compatibility
export { Minimatch, minimatch } from 'minimatch'

// Re-export Minipass for stream API compatibility
import { Minipass } from 'minipass'
export { Minipass }

// Types
export interface GlobOptions {
  // Path options
  cwd?: string
  root?: string

  // Pattern options
  dot?: boolean
  nobrace?: boolean
  noglobstar?: boolean
  noext?: boolean
  nocase?: boolean
  magicalBraces?: boolean

  // Traversal options
  follow?: boolean
  maxDepth?: number
  matchBase?: boolean

  // Output options
  absolute?: boolean
  dotRelative?: boolean
  mark?: boolean
  nodir?: boolean
  posix?: boolean
  withFileTypes?: boolean

  // Performance options
  stat?: boolean
  realpath?: boolean

  // Filtering options
  ignore?: string | string[] | IgnorePattern
  includeChildMatches?: boolean

  // Platform options
  platform?: 'linux' | 'darwin' | 'win32'
  windowsPathsNoEscape?: boolean

  // Control options
  signal?: AbortSignal
}

export interface IgnorePattern {
  ignored?: (path: string) => boolean
  childrenIgnored?: (path: string) => boolean
}

/**
 * Synchronous glob pattern matching
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @returns Array of matching file paths
 */
export function globSync(
  pattern: string | string[],
  options?: GlobOptions
): string[] {
  const opts = {
    cwd: options?.cwd ?? process.cwd(),
    ...options,
  }

  // Pass patterns directly to native implementation (supports both string and array)
  return nativeGlobSync(pattern, opts)
}

/**
 * Asynchronous glob pattern matching
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @returns Promise resolving to array of matching file paths
 */
export async function glob(
  pattern: string | string[],
  options?: GlobOptions
): Promise<string[]> {
  const opts = {
    cwd: options?.cwd ?? process.cwd(),
    ...options,
  }

  // Use native async implementation (supports both string and array)
  return nativeGlob(pattern, opts)
}

/**
 * Streaming glob pattern matching
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @returns Minipass stream of matching file paths
 */
export function globStream(
  pattern: string | string[],
  options?: GlobOptions
): Minipass<string, string> {
  const stream = new Minipass<string, string>({ objectMode: true })

  // TODO: Implement proper streaming
  setImmediate(() => {
    try {
      const results = globSync(pattern, options)
      for (const result of results) {
        stream.write(result)
      }
      stream.end()
    } catch (err) {
      stream.emit('error', err)
    }
  })

  return stream
}

/**
 * Synchronous streaming glob pattern matching
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @returns Minipass stream of matching file paths
 */
export function globStreamSync(
  pattern: string | string[],
  options?: GlobOptions
): Minipass<string, string> {
  const stream = new Minipass<string, string>({ objectMode: true })

  const results = globSync(pattern, options)
  for (const result of results) {
    stream.write(result)
  }
  stream.end()

  return stream
}

/**
 * Async iterator for glob results
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @yields Matching file paths
 */
export async function* globIterate(
  pattern: string | string[],
  options?: GlobOptions
): AsyncGenerator<string, void, void> {
  // TODO: Implement proper async iteration
  const results = await glob(pattern, options)
  for (const result of results) {
    yield result
  }
}

/**
 * Sync iterator for glob results
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @yields Matching file paths
 */
export function* globIterateSync(
  pattern: string | string[],
  options?: GlobOptions
): Generator<string, void, void> {
  const results = globSync(pattern, options)
  for (const result of results) {
    yield result
  }
}

/**
 * Check if a pattern contains any magic glob characters.
 * Takes into account escaped characters - escaped magic chars don't count.
 *
 * @param pattern - Glob pattern or array of patterns
 * @param options - Glob options
 * @returns True if the pattern has magic (unescaped) glob characters
 */
export function hasMagic(
  pattern: string | string[],
  options?: GlobOptions
): boolean {
  const patterns = Array.isArray(pattern) ? pattern : [pattern]
  const noext = options?.noext ?? false
  const windowsPathsNoEscape = options?.windowsPathsNoEscape ?? false

  for (const p of patterns) {
    if (nativeHasMagic(p, noext, windowsPathsNoEscape)) {
      return true
    }
  }

  return false
}

/**
 * Escape magic glob characters in a pattern.
 * After escaping, the pattern will match the literal string.
 *
 * @param pattern - Pattern to escape
 * @param options - Glob options (windowsPathsNoEscape affects escape style)
 * @returns Escaped pattern
 */
export function escape(pattern: string, options?: GlobOptions): string {
  const windowsPathsNoEscape = options?.windowsPathsNoEscape ?? false
  return nativeEscape(pattern, windowsPathsNoEscape)
}

/**
 * Unescape magic glob characters in a pattern.
 * This reverses the effect of `escape()`.
 *
 * @param pattern - Pattern to unescape
 * @param options - Glob options (windowsPathsNoEscape affects unescape style)
 * @returns Unescaped pattern
 */
export function unescape(pattern: string, options?: GlobOptions): string {
  const windowsPathsNoEscape = options?.windowsPathsNoEscape ?? false
  return nativeUnescape(pattern, windowsPathsNoEscape)
}

/**
 * Glob class for reusable glob operations
 */
export class Glob {
  readonly pattern: string[]
  readonly options: GlobOptions

  constructor(pattern: string | string[], options: GlobOptions = {}) {
    // Validate options on construction (same as glob v13)
    if (options.withFileTypes && options.absolute !== undefined) {
      throw new TypeError('cannot set absolute and withFileTypes:true')
    }
    if (options.matchBase && options.noglobstar) {
      throw new TypeError('base matching requires globstar')
    }

    this.pattern = Array.isArray(pattern) ? pattern : [pattern]
    this.options = options
  }

  walk(): Promise<string[]> {
    return glob(this.pattern, this.options)
  }

  walkSync(): string[] {
    return globSync(this.pattern, this.options)
  }

  stream(): Minipass<string, string> {
    return globStream(this.pattern, this.options)
  }

  streamSync(): Minipass<string, string> {
    return globStreamSync(this.pattern, this.options)
  }

  iterate(): AsyncGenerator<string, void, void> {
    return globIterate(this.pattern, this.options)
  }

  iterateSync(): Generator<string, void, void> {
    return globIterateSync(this.pattern, this.options)
  }

  // Make the class iterable
  [Symbol.asyncIterator](): AsyncGenerator<string, void, void> {
    return this.iterate()
  }

  [Symbol.iterator](): Generator<string, void, void> {
    return this.iterateSync()
  }
}

// Default export
export default glob
